# DatabaseManager æ¶æ„è®¾è®¡ï¼ˆä¼˜åŒ–ç‰ˆ v2ï¼‰

é«˜æ€§èƒ½æ•°æ®åº“ç®¡ç†åç«¯ï¼ŒåŸºäº Rust + Axum + SQLx

---

## ç›®å½•

1. [é¡¹ç›®ç®€ä»‹](#1-é¡¹ç›®ç®€ä»‹)
2. [ç³»ç»Ÿæ¶æ„](#2-ç³»ç»Ÿæ¶æ„)
3. [æ¨¡å—ç»“æ„](#3-æ¨¡å—ç»“æ„)
4. [æ ¸å¿ƒæ¨¡å—è®¾è®¡](#4-æ ¸å¿ƒæ¨¡å—è®¾è®¡)
5. [æ•°æ®æ¨¡å‹](#5-æ•°æ®æ¨¡å‹)
6. [æœåŠ¡å±‚è®¾è®¡](#6-æœåŠ¡å±‚è®¾è®¡)
7. [åŠ¨æ€è¿æ¥æ± ç®¡ç†](#7-åŠ¨æ€è¿æ¥æ± ç®¡ç†)
8. [ç»Ÿä¸€é”™è¯¯å¤„ç†](#8-ç»Ÿä¸€é”™è¯¯å¤„ç†)
9. [API æ¥å£è®¾è®¡](#9-api-æ¥å£è®¾è®¡)
10. [AI æ™ºèƒ½åŠŸèƒ½](#10-ai-æ™ºèƒ½åŠŸèƒ½) â­ æ–°å¢
11. [ä¸­é—´ä»¶é…ç½®](#11-ä¸­é—´ä»¶é…ç½®)
12. [é…ç½®æŒä¹…åŒ–](#12-é…ç½®æŒä¹…åŒ–)
13. [æ—¥å¿—è§„èŒƒ](#13-æ—¥å¿—è§„èŒƒ)
14. [å®‰å…¨æ€§è®¾è®¡](#14-å®‰å…¨æ€§è®¾è®¡)
15. [æ€§èƒ½ä¼˜åŒ–](#15-æ€§èƒ½ä¼˜åŒ–)
16. [ç›‘æ§ä¸æŒ‡æ ‡](#16-ç›‘æ§ä¸æŒ‡æ ‡)
17. [éƒ¨ç½²æ–¹æ¡ˆ](#17-éƒ¨ç½²æ–¹æ¡ˆ)
18. [æµ‹è¯•ç­–ç•¥](#18-æµ‹è¯•ç­–ç•¥)
19. [ä¾èµ–é…ç½®](#19-ä¾èµ–é…ç½®)
20. [å¼€å‘è·¯çº¿å›¾](#20-å¼€å‘è·¯çº¿å›¾)
21. [é™„å½•](#é™„å½•)

---

## 1. é¡¹ç›®ç®€ä»‹

### 1.1 æ ¸å¿ƒç›®æ ‡

å®‰å…¨åœ°ç®¡ç†å¤šç§æ•°æ®åº“è¿æ¥ï¼ˆMySQL/PostgreSQL/SQLite/ClickHouseï¼‰ï¼Œå¹¶æ”¯æŒæ‰§è¡Œ SQL æŸ¥è¯¢ã€‚

### 1.2 æŠ€æœ¯æ ˆ

| ç»„ä»¶ | æŠ€æœ¯é€‰å‹ | è¯´æ˜ |
|------|---------|------|
| Web æ¡†æ¶ | Axum 0.8 | é«˜æ€§èƒ½å¼‚æ­¥ Web æ¡†æ¶ï¼ŒåŸºäº Tower ç”Ÿæ€ |
| å¼‚æ­¥è¿è¡Œæ—¶ | Tokio | å…¨åŠŸèƒ½å¼‚æ­¥è¿è¡Œæ—¶ |
| æ•°æ®åº“è®¿é—® | SQLx | ç¼–è¯‘æ—¶ SQL æ£€æŸ¥ï¼Œå¤šæ•°æ®åº“æ”¯æŒ |
| åºåˆ—åŒ– | Serde | JSON åºåˆ—åŒ–/ååºåˆ—åŒ– |
| æ—¥å¿— | tracing | ç»“æ„åŒ–æ—¥å¿—ï¼Œæ”¯æŒåˆ†å¸ƒå¼è¿½è¸ª |
| é”™è¯¯å¤„ç† | thiserror | è‡ªå®šä¹‰é”™è¯¯ç±»å‹ |
| é…ç½®ç®¡ç† | ç¯å¢ƒå˜é‡ | æ”¯æŒ .env æ–‡ä»¶ |

### 1.3 è®¾è®¡åŸåˆ™

- **åˆ†å±‚æ¶æ„**ï¼šè·¯ç”±å±‚ â†’ æœåŠ¡å±‚ â†’ æ•°æ®è®¿é—®å±‚ï¼ŒèŒè´£æ¸…æ™°
- **ä¾èµ–æ³¨å…¥**ï¼šé€šè¿‡ AppState å…±äº«ä¾èµ–ï¼Œä¾¿äºæµ‹è¯•
- **é”™è¯¯é€æ˜**ï¼šç»Ÿä¸€é”™è¯¯å¤„ç†ï¼Œå‰ç«¯å‹å¥½çš„é”™è¯¯ä¿¡æ¯
- **å®‰å…¨ä¼˜å…ˆ**ï¼šå¯†ç ä¸è½æ—¥å¿—ã€SQL æ³¨å…¥é˜²æŠ¤ã€è®¤è¯æœºåˆ¶
- **å¯è§‚æµ‹æ€§**ï¼šç»“æ„åŒ–æ—¥å¿—ã€å¥åº·æ£€æŸ¥ã€ç›‘æ§æŒ‡æ ‡

---

## 2. ç³»ç»Ÿæ¶æ„

### 2.1 æ•´ä½“æ¶æ„å›¾

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                         å®¢æˆ·ç«¯ (å‰ç«¯/API)                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â”‚ HTTP/JSON
                              â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                        ä¸­é—´ä»¶å±‚ (Middleware)                      â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚  CORS    â”‚  â”‚  Trace   â”‚  â”‚ Compress â”‚  â”‚  Auth (å¯é€‰)     â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                         è·¯ç”±å±‚ (Routes)                          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚ /api/health  â”‚  â”‚/api/connectionsâ”‚  â”‚/api/.../query      â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                        æœåŠ¡å±‚ (Services)                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚ ConnectionService  â”‚  â”‚        QueryService                â”‚ â”‚
â”‚  â”‚ - create/delete    â”‚  â”‚ - execute_query                    â”‚ â”‚
â”‚  â”‚ - test/list        â”‚  â”‚ - parse_result                     â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
             â–¼                               â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      æ•°æ®è®¿é—®å±‚ (DB Layer)                        â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚                    PoolManager                            â”‚   â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚   â”‚
â”‚  â”‚  â”‚ MySQL Pools â”‚ â”‚ PG Pools    â”‚ â”‚ SQLite Pools        â”‚ â”‚   â”‚
â”‚  â”‚  â”‚ HashMap<id> â”‚ â”‚ HashMap<id> â”‚ â”‚ HashMap<id>         â”‚ â”‚   â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                        å¤–éƒ¨æ•°æ®åº“                                 â”‚
â”‚    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”‚
â”‚    â”‚  MySQL  â”‚      â”‚ PostgreSQL â”‚      â”‚     SQLite      â”‚     â”‚
â”‚    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 2.2 è¯·æ±‚å¤„ç†æµç¨‹

```
HTTP Request
    â”‚
    â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Middleware    â”‚ â† æ—¥å¿—è®°å½•ã€CORSã€è®¤è¯
â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
        â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Router        â”‚ â† è·¯ç”±åŒ¹é…
â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
        â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Handler       â”‚ â† è¯·æ±‚è§£æã€å‚æ•°éªŒè¯
â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
        â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Service       â”‚ â† ä¸šåŠ¡é€»è¾‘å¤„ç†
â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
        â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ PoolManager   â”‚ â† è·å–æ•°æ®åº“è¿æ¥
â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
        â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Database      â”‚ â† æ‰§è¡Œ SQL
â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
        â–¼
HTTP Response (JSON)
```

---

## 3. æ¨¡å—ç»“æ„

```text
src/
â”œâ”€â”€ main.rs                    # åº”ç”¨å…¥å£ï¼ˆä»…å¯åŠ¨é€»è¾‘ï¼‰
â”œâ”€â”€ lib.rs                     # åº“å…¥å£ï¼Œå¯¼å‡ºå…¬å…±æ¨¡å—
â”œâ”€â”€ config.rs                  # é…ç½®ç®¡ç†
â”œâ”€â”€ state.rs                   # åº”ç”¨çŠ¶æ€ï¼ˆAppStateï¼‰
â”‚
â”œâ”€â”€ routes/                    # API è·¯ç”±å±‚
â”‚   â”œâ”€â”€ mod.rs                 # è·¯ç”±æ³¨å†Œ + create_router()
â”‚   â”œâ”€â”€ health.rs              # å¥åº·æ£€æŸ¥ API
â”‚   â”œâ”€â”€ connections.rs         # è¿æ¥ç®¡ç† API
â”‚   â””â”€â”€ ai.rs                  # AI åŠŸèƒ½ API â­
â”‚
â”œâ”€â”€ models/                    # æ•°æ®æ¨¡å‹å±‚
â”‚   â”œâ”€â”€ mod.rs
â”‚   â”œâ”€â”€ connection.rs          # ConnectionConfig, DbType
â”‚   â”œâ”€â”€ query.rs               # QueryRequest, QueryResult
â”‚   â””â”€â”€ response.rs            # ApiResponse<T>
â”‚
â”œâ”€â”€ services/                  # ä¸šåŠ¡é€»è¾‘å±‚
â”‚   â”œâ”€â”€ mod.rs
â”‚   â”œâ”€â”€ connection_service.rs  # è¿æ¥ç®¡ç†æœåŠ¡
â”‚   â””â”€â”€ query_service.rs       # SQL æŸ¥è¯¢æœåŠ¡
â”‚
â”œâ”€â”€ ai/                        # AI åŠŸèƒ½æ¨¡å— â­
â”‚   â”œâ”€â”€ mod.rs                 # æ¨¡å—å…¥å£
â”‚   â”œâ”€â”€ llm_client.rs          # LLM API å®¢æˆ·ç«¯
â”‚   â”œâ”€â”€ text2sql.rs            # è‡ªç„¶è¯­è¨€è½¬ SQL
â”‚   â”œâ”€â”€ sql_optimizer.rs       # SQL ä¼˜åŒ–å»ºè®®
â”‚   â”œâ”€â”€ data_analyzer.rs       # æ•°æ®åˆ†æ
â”‚   â”œâ”€â”€ schema_manager.rs      # Schema ç®¡ç†
â”‚   â””â”€â”€ prompt_templates.rs    # Prompt æ¨¡æ¿
â”‚
â”œâ”€â”€ db/                        # æ•°æ®è®¿é—®å±‚
â”‚   â”œâ”€â”€ mod.rs
â”‚   â”œâ”€â”€ pool_manager.rs        # åŠ¨æ€è¿æ¥æ± ç®¡ç†
â”‚   â””â”€â”€ executor.rs            # SQL æ‰§è¡Œå™¨ï¼ˆå¤šæ•°æ®åº“é€‚é…ï¼‰
â”‚
â”œâ”€â”€ errors/                    # é”™è¯¯å¤„ç†
â”‚   â”œâ”€â”€ mod.rs
â”‚   â””â”€â”€ app_error.rs           # ç»Ÿä¸€é”™è¯¯ç±»å‹
â”‚
â”œâ”€â”€ middleware/                # ä¸­é—´ä»¶
â”‚   â”œâ”€â”€ mod.rs
â”‚   â”œâ”€â”€ auth.rs                # è®¤è¯ä¸­é—´ä»¶
â”‚   â””â”€â”€ request_id.rs          # è¯·æ±‚ ID è¿½è¸ª
â”‚
â””â”€â”€ utils/                     # å·¥å…·æ¨¡å—
    â”œâ”€â”€ mod.rs
    â”œâ”€â”€ id_generator.rs        # UUID ç”Ÿæˆå™¨
    â””â”€â”€ sql_validator.rs       # SQL å®‰å…¨æ£€æŸ¥
```

---

## 4. æ ¸å¿ƒæ¨¡å—è®¾è®¡

### 4.1 åº”ç”¨å…¥å£ (main.rs)

```rust
use std::net::SocketAddr;
use tokio::net::TcpListener;
use tracing_subscriber::{layer::SubscriberExt, util::SubscriberInitExt};

mod config;
mod state;
mod routes;
mod models;
mod services;
mod db;
mod errors;
mod middleware;
mod utils;

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    // 1. åŠ è½½é…ç½®
    let config = config::AppConfig::load();

    // 2. åˆå§‹åŒ–æ—¥å¿—
    init_tracing(&config.log_level);
    tracing::info!(version = env!("CARGO_PKG_VERSION"), "å¯åŠ¨ DatabaseManager");

    // 3. åˆå§‹åŒ–åº”ç”¨çŠ¶æ€
    let app_state = state::AppState::new(config.clone()).await?;

    // 4. æ„å»ºè·¯ç”±
    let app = routes::create_router(app_state);

    // 5. å¯åŠ¨æœåŠ¡
    let addr: SocketAddr = config.addr().parse()?;
    tracing::info!(%addr, "æœåŠ¡ç›‘å¬ä¸­");

    let listener = TcpListener::bind(addr).await?;
    axum::serve(listener, app.into_make_service())
        .with_graceful_shutdown(shutdown_signal())
        .await?;

    tracing::info!("æœåŠ¡å·²å…³é—­");
    Ok(())
}

fn init_tracing(log_level: &str) {
    tracing_subscriber::registry()
        .with(tracing_subscriber::EnvFilter::new(log_level))
        .with(tracing_subscriber::fmt::layer().json()) // JSON æ ¼å¼æ—¥å¿—
        .init();
}

async fn shutdown_signal() {
    let ctrl_c = async {
        tokio::signal::ctrl_c().await.expect("failed to listen for ctrl+c");
    };

    #[cfg(unix)]
    let terminate = async {
        tokio::signal::unix::signal(tokio::signal::unix::SignalKind::terminate())
            .expect("failed to install signal handler")
            .recv()
            .await;
    };

    #[cfg(not(unix))]
    let terminate = std::future::pending::<()>();

    tokio::select! {
        _ = ctrl_c => tracing::info!("æ”¶åˆ° SIGINT"),
        _ = terminate => tracing::info!("æ”¶åˆ° SIGTERM"),
    }
}
```

### 4.2 é…ç½®ç®¡ç† (config.rs)

```rust
use serde::Deserialize;

#[derive(Debug, Clone, Deserialize)]
pub struct AppConfig {
    /// æœåŠ¡ç›‘å¬åœ°å€
    #[serde(default = "default_host")]
    pub host: String,

    /// æœåŠ¡ç›‘å¬ç«¯å£
    #[serde(default = "default_port")]
    pub port: u16,

    /// æ—¥å¿—çº§åˆ«
    #[serde(default = "default_log_level")]
    pub log_level: String,

    /// è¿æ¥æ± æœ€å¤§è¿æ¥æ•°
    #[serde(default = "default_max_connections")]
    pub max_connections: u32,

    /// è¿æ¥è¶…æ—¶ï¼ˆç§’ï¼‰
    #[serde(default = "default_connect_timeout")]
    pub connect_timeout_secs: u64,

    /// é…ç½®æŒä¹…åŒ–è·¯å¾„
    #[serde(default = "default_data_dir")]
    pub data_dir: String,
}

fn default_host() -> String { "0.0.0.0".into() }
fn default_port() -> u16 { 8080 }
fn default_log_level() -> String { "info".into() }
fn default_max_connections() -> u32 { 10 }
fn default_connect_timeout() -> u64 { 30 }
fn default_data_dir() -> String { "./data".into() }

impl AppConfig {
    pub fn load() -> Self {
        Self {
            host: std::env::var("SERVER_HOST").unwrap_or_else(|_| default_host()),
            port: std::env::var("SERVER_PORT")
                .ok()
                .and_then(|p| p.parse().ok())
                .unwrap_or_else(default_port),
            log_level: std::env::var("RUST_LOG").unwrap_or_else(|_| default_log_level()),
            max_connections: std::env::var("MAX_CONNECTIONS")
                .ok()
                .and_then(|p| p.parse().ok())
                .unwrap_or_else(default_max_connections),
            connect_timeout_secs: std::env::var("CONNECT_TIMEOUT")
                .ok()
                .and_then(|p| p.parse().ok())
                .unwrap_or_else(default_connect_timeout),
            data_dir: std::env::var("DATA_DIR").unwrap_or_else(|_| default_data_dir()),
        }
    }

    pub fn addr(&self) -> String {
        format!("{}:{}", self.host, self.port)
    }
}
```

### 4.3 åº”ç”¨çŠ¶æ€ (state.rs)

```rust
use std::sync::Arc;
use crate::config::AppConfig;
use crate::db::PoolManager;
use crate::services::{ConnectionService, QueryService};

#[derive(Clone)]
pub struct AppState {
    pub config: AppConfig,
    pub pool_manager: Arc<PoolManager>,
    pub connection_service: Arc<ConnectionService>,
    pub query_service: Arc<QueryService>,
}

impl AppState {
    pub async fn new(config: AppConfig) -> anyhow::Result<Self> {
        let pool_manager = Arc::new(PoolManager::new(config.clone()));

        // åŠ è½½æŒä¹…åŒ–çš„è¿æ¥é…ç½®
        pool_manager.load_from_disk().await?;

        let connection_service = Arc::new(ConnectionService::new(pool_manager.clone()));
        let query_service = Arc::new(QueryService::new(pool_manager.clone()));

        Ok(Self {
            config,
            pool_manager,
            connection_service,
            query_service,
        })
    }
}
```

### 4.4 è·¯ç”±æ³¨å†Œ (routes/mod.rs)

```rust
use axum::{
    Router,
    routing::{get, post, delete},
    http::Method,
};
use tower_http::{
    cors::{CorsLayer, Any},
    trace::TraceLayer,
    compression::CompressionLayer,
};
use crate::state::AppState;

pub mod health;
pub mod connections;

pub fn create_router(state: AppState) -> Router {
    // CORS é…ç½®
    let cors = CorsLayer::new()
        .allow_origin(Any) // ç”Ÿäº§ç¯å¢ƒåº”é™åˆ¶
        .allow_methods([Method::GET, Method::POST, Method::DELETE, Method::OPTIONS])
        .allow_headers(Any);

    Router::new()
        // å¥åº·æ£€æŸ¥
        .route("/api/health", get(health::health_check))
        .route("/api/health/ready", get(health::readiness_check))
        .route("/api/health/live", get(health::liveness_check))
        // è¿æ¥ç®¡ç†
        .route("/api/connections", get(connections::list))
        .route("/api/connections", post(connections::create))
        .route("/api/connections/:id", get(connections::get))
        .route("/api/connections/:id", delete(connections::delete))
        .route("/api/connections/:id/test", post(connections::test))
        .route("/api/connections/:id/query", post(connections::query))
        // ä¸­é—´ä»¶ï¼ˆé¡ºåºï¼šä»ä¸‹å¾€ä¸Šæ‰§è¡Œï¼‰
        .layer(CompressionLayer::new())
        .layer(TraceLayer::new_for_http())
        .layer(cors)
        // å…±äº«çŠ¶æ€
        .with_state(state)
}
```

---

## 5. æ•°æ®æ¨¡å‹

### 5.1 è¿æ¥é…ç½® (models/connection.rs)

```rust
use serde::{Deserialize, Serialize};
use uuid::Uuid;

/// æ•°æ®åº“ç±»å‹
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
#[serde(rename_all = "lowercase")]
pub enum DbType {
    MySQL,
    Postgres,
    SQLite,
}

impl DbType {
    pub fn default_port(&self) -> u16 {
        match self {
            DbType::MySQL => 3306,
            DbType::Postgres => 5432,
            DbType::SQLite => 0,
        }
    }
}

/// è¿æ¥é…ç½®
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ConnectionConfig {
    /// å”¯ä¸€æ ‡è¯†
    #[serde(default = "generate_id")]
    pub id: String,

    /// è¿æ¥åˆ«å
    pub name: String,

    /// æ•°æ®åº“ç±»å‹
    #[serde(rename = "type")]
    pub db_type: DbType,

    /// ä¸»æœºåœ°å€ï¼ˆMySQL/Postgresï¼‰
    #[serde(skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,

    /// ç«¯å£å·
    #[serde(skip_serializing_if = "Option::is_none")]
    pub port: Option<u16>,

    /// ç”¨æˆ·å
    #[serde(skip_serializing_if = "Option::is_none")]
    pub username: Option<String>,

    /// å¯†ç ï¼ˆå“åº”æ—¶ä¸è¿”å›ï¼‰
    #[serde(skip_serializing, default)]
    pub password: Option<String>,

    /// æ•°æ®åº“å
    #[serde(skip_serializing_if = "Option::is_none")]
    pub database: Option<String>,

    /// æ–‡ä»¶è·¯å¾„ï¼ˆSQLite ä¸“ç”¨ï¼‰
    #[serde(skip_serializing_if = "Option::is_none")]
    pub file_path: Option<String>,

    /// åˆ›å»ºæ—¶é—´
    #[serde(default = "chrono::Utc::now")]
    pub created_at: chrono::DateTime<chrono::Utc>,
}

fn generate_id() -> String {
    Uuid::new_v4().to_string()
}

/// è¿æ¥çŠ¶æ€
#[derive(Debug, Serialize)]
pub struct ConnectionStatus {
    pub id: String,
    pub name: String,
    pub db_type: DbType,
    pub is_connected: bool,
    pub latency_ms: Option<u64>,
    pub error: Option<String>,
}

/// åˆ›å»ºè¿æ¥è¯·æ±‚
#[derive(Debug, Deserialize)]
pub struct CreateConnectionRequest {
    pub name: String,
    #[serde(rename = "type")]
    pub db_type: DbType,
    pub host: Option<String>,
    pub port: Option<u16>,
    pub username: Option<String>,
    pub password: Option<String>,
    pub database: Option<String>,
    pub file_path: Option<String>,
}

impl CreateConnectionRequest {
    pub fn into_config(self) -> ConnectionConfig {
        ConnectionConfig {
            id: generate_id(),
            name: self.name,
            db_type: self.db_type,
            host: self.host,
            port: self.port,
            username: self.username,
            password: self.password,
            database: self.database,
            file_path: self.file_path,
            created_at: chrono::Utc::now(),
        }
    }
}
```

### 5.2 æŸ¥è¯¢æ¨¡å‹ (models/query.rs)

```rust
use serde::{Deserialize, Serialize};

/// SQL æŸ¥è¯¢è¯·æ±‚
#[derive(Debug, Deserialize)]
pub struct QueryRequest {
    /// SQL è¯­å¥
    pub sql: String,

    /// æŸ¥è¯¢å‚æ•°ï¼ˆå¯é€‰ï¼‰
    #[serde(default)]
    pub params: Vec<serde_json::Value>,

    /// æœ€å¤§è¿”å›è¡Œæ•°
    #[serde(default = "default_limit")]
    pub limit: usize,
}

fn default_limit() -> usize { 1000 }

/// æŸ¥è¯¢ç»“æœ
#[derive(Debug, Serialize)]
pub struct QueryResult {
    /// åˆ—ååˆ—è¡¨
    pub columns: Vec<ColumnInfo>,

    /// æ•°æ®è¡Œ
    pub rows: Vec<Vec<serde_json::Value>>,

    /// è¿”å›è¡Œæ•°
    pub row_count: usize,

    /// å½±å“è¡Œæ•°ï¼ˆINSERT/UPDATE/DELETEï¼‰
    #[serde(skip_serializing_if = "Option::is_none")]
    pub affected_rows: Option<u64>,

    /// æ‰§è¡Œè€—æ—¶ï¼ˆæ¯«ç§’ï¼‰
    pub execution_time_ms: u64,
}

/// åˆ—ä¿¡æ¯
#[derive(Debug, Serialize)]
pub struct ColumnInfo {
    pub name: String,
    pub data_type: String,
}
```

### 5.3 é€šç”¨å“åº” (models/response.rs)

```rust
use axum::{http::StatusCode, response::IntoResponse, Json};
use serde::Serialize;

/// ç»Ÿä¸€ API å“åº”æ ¼å¼
#[derive(Debug, Serialize)]
pub struct ApiResponse<T: Serialize> {
    pub success: bool,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub data: Option<T>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub error: Option<ErrorDetail>,
}

#[derive(Debug, Serialize)]
pub struct ErrorDetail {
    pub code: String,
    pub message: String,
}

impl<T: Serialize> ApiResponse<T> {
    pub fn ok(data: T) -> Self {
        Self {
            success: true,
            data: Some(data),
            error: None,
        }
    }

    pub fn created(data: T) -> (StatusCode, Json<Self>) {
        (StatusCode::CREATED, Json(Self::ok(data)))
    }
}

impl ApiResponse<()> {
    pub fn err(code: impl Into<String>, message: impl Into<String>) -> Self {
        Self {
            success: false,
            data: None,
            error: Some(ErrorDetail {
                code: code.into(),
                message: message.into(),
            }),
        }
    }

    pub fn deleted() -> Self {
        Self {
            success: true,
            data: None,
            error: None,
        }
    }
}
```

---

## 6. æœåŠ¡å±‚è®¾è®¡

### 6.1 è¿æ¥æœåŠ¡ (services/connection_service.rs)

```rust
use std::sync::Arc;
use crate::db::PoolManager;
use crate::errors::AppError;
use crate::models::connection::{
    ConnectionConfig, ConnectionStatus, CreateConnectionRequest,
};

pub struct ConnectionService {
    pool_manager: Arc<PoolManager>,
}

impl ConnectionService {
    pub fn new(pool_manager: Arc<PoolManager>) -> Self {
        Self { pool_manager }
    }

    /// åˆ›å»ºæ–°è¿æ¥
    pub async fn create(&self, req: CreateConnectionRequest) -> Result<ConnectionConfig, AppError> {
        let config = req.into_config();

        // éªŒè¯é…ç½®
        self.validate_config(&config)?;

        // æµ‹è¯•è¿æ¥æ˜¯å¦å¯ç”¨
        self.pool_manager.add_connection(config.clone()).await?;

        // æŒä¹…åŒ–é…ç½®
        self.pool_manager.save_to_disk().await?;

        tracing::info!(id = %config.id, name = %config.name, "è¿æ¥åˆ›å»ºæˆåŠŸ");
        Ok(config)
    }

    /// è·å–æ‰€æœ‰è¿æ¥
    pub async fn list(&self) -> Vec<ConnectionConfig> {
        self.pool_manager.list_connections().await
    }

    /// è·å–å•ä¸ªè¿æ¥
    pub async fn get(&self, id: &str) -> Result<ConnectionConfig, AppError> {
        self.pool_manager
            .get_connection(id)
            .await
            .ok_or_else(|| AppError::ConnectionNotFound(id.to_string()))
    }

    /// åˆ é™¤è¿æ¥
    pub async fn delete(&self, id: &str) -> Result<(), AppError> {
        self.pool_manager.remove_connection(id).await?;
        self.pool_manager.save_to_disk().await?;
        tracing::info!(id = %id, "è¿æ¥å·²åˆ é™¤");
        Ok(())
    }

    /// æµ‹è¯•è¿æ¥
    pub async fn test(&self, id: &str) -> Result<ConnectionStatus, AppError> {
        let start = std::time::Instant::now();
        let result = self.pool_manager.test_connection(id).await;
        let latency = start.elapsed().as_millis() as u64;

        let config = self.get(id).await?;

        Ok(ConnectionStatus {
            id: id.to_string(),
            name: config.name,
            db_type: config.db_type,
            is_connected: result.is_ok(),
            latency_ms: result.is_ok().then_some(latency),
            error: result.err().map(|e| e.to_string()),
        })
    }

    fn validate_config(&self, config: &ConnectionConfig) -> Result<(), AppError> {
        if config.name.trim().is_empty() {
            return Err(AppError::Validation("è¿æ¥åç§°ä¸èƒ½ä¸ºç©º".into()));
        }

        match config.db_type {
            crate::models::connection::DbType::SQLite => {
                if config.file_path.is_none() {
                    return Err(AppError::Validation("SQLite éœ€è¦æŒ‡å®š file_path".into()));
                }
            }
            _ => {
                if config.host.is_none() {
                    return Err(AppError::Validation("éœ€è¦æŒ‡å®š host".into()));
                }
            }
        }

        Ok(())
    }
}
```

### 6.2 æŸ¥è¯¢æœåŠ¡ (services/query_service.rs)

```rust
use std::sync::Arc;
use crate::db::PoolManager;
use crate::errors::AppError;
use crate::models::query::{QueryRequest, QueryResult};
use crate::utils::sql_validator::SqlValidator;

pub struct QueryService {
    pool_manager: Arc<PoolManager>,
}

impl QueryService {
    pub fn new(pool_manager: Arc<PoolManager>) -> Self {
        Self { pool_manager }
    }

    /// æ‰§è¡Œ SQL æŸ¥è¯¢
    pub async fn execute(&self, connection_id: &str, req: QueryRequest) -> Result<QueryResult, AppError> {
        // SQL å®‰å…¨æ£€æŸ¥
        SqlValidator::validate(&req.sql)?;

        let start = std::time::Instant::now();

        let result = self.pool_manager
            .execute_query(connection_id, &req.sql, req.limit)
            .await?;

        let execution_time = start.elapsed().as_millis() as u64;

        tracing::info!(
            connection_id = %connection_id,
            row_count = result.row_count,
            execution_time_ms = execution_time,
            "SQL æ‰§è¡Œå®Œæˆ"
        );

        Ok(QueryResult {
            execution_time_ms: execution_time,
            ..result
        })
    }
}
```

---

## 7. åŠ¨æ€è¿æ¥æ± ç®¡ç†

### 7.1 PoolManager (db/pool_manager.rs)

```rust
use std::collections::HashMap;
use std::path::PathBuf;
use tokio::sync::RwLock;
use sqlx::{mysql::MySqlPoolOptions, postgres::PgPoolOptions, sqlite::SqlitePoolOptions};
use sqlx::{MySqlPool, PgPool, SqlitePool, Row};
use crate::config::AppConfig;
use crate::errors::AppError;
use crate::models::connection::{ConnectionConfig, DbType};
use crate::models::query::{QueryResult, ColumnInfo};

pub struct PoolManager {
    config: AppConfig,
    mysql_pools: RwLock<HashMap<String, MySqlPool>>,
    postgres_pools: RwLock<HashMap<String, PgPool>>,
    sqlite_pools: RwLock<HashMap<String, SqlitePool>>,
    configs: RwLock<HashMap<String, ConnectionConfig>>,
}

impl PoolManager {
    pub fn new(config: AppConfig) -> Self {
        Self {
            config,
            mysql_pools: RwLock::new(HashMap::new()),
            postgres_pools: RwLock::new(HashMap::new()),
            sqlite_pools: RwLock::new(HashMap::new()),
            configs: RwLock::new(HashMap::new()),
        }
    }

    /// æ·»åŠ æ–°è¿æ¥
    pub async fn add_connection(&self, config: ConnectionConfig) -> Result<(), AppError> {
        let id = config.id.clone();
        let timeout = std::time::Duration::from_secs(self.config.connect_timeout_secs);

        match config.db_type {
            DbType::MySQL => {
                let url = self.build_mysql_url(&config);
                let pool = MySqlPoolOptions::new()
                    .max_connections(self.config.max_connections)
                    .acquire_timeout(timeout)
                    .connect(&url)
                    .await?;
                self.mysql_pools.write().await.insert(id.clone(), pool);
            }
            DbType::Postgres => {
                let url = self.build_postgres_url(&config);
                let pool = PgPoolOptions::new()
                    .max_connections(self.config.max_connections)
                    .acquire_timeout(timeout)
                    .connect(&url)
                    .await?;
                self.postgres_pools.write().await.insert(id.clone(), pool);
            }
            DbType::SQLite => {
                let path = config.file_path.as_deref().unwrap_or("data.db");
                let url = format!("sqlite:{}?mode=rwc", path);
                let pool = SqlitePoolOptions::new()
                    .max_connections(1) // SQLite å•è¿æ¥
                    .connect(&url)
                    .await?;
                self.sqlite_pools.write().await.insert(id.clone(), pool);
            }
        }

        self.configs.write().await.insert(id, config);
        Ok(())
    }

    /// æµ‹è¯•è¿æ¥
    pub async fn test_connection(&self, id: &str) -> Result<(), AppError> {
        let configs = self.configs.read().await;
        let config = configs.get(id)
            .ok_or_else(|| AppError::ConnectionNotFound(id.to_string()))?;

        match config.db_type {
            DbType::MySQL => {
                let pools = self.mysql_pools.read().await;
                let pool = pools.get(id)
                    .ok_or_else(|| AppError::ConnectionNotFound(id.to_string()))?;
                sqlx::query("SELECT 1").execute(pool).await?;
            }
            DbType::Postgres => {
                let pools = self.postgres_pools.read().await;
                let pool = pools.get(id)
                    .ok_or_else(|| AppError::ConnectionNotFound(id.to_string()))?;
                sqlx::query("SELECT 1").execute(pool).await?;
            }
            DbType::SQLite => {
                let pools = self.sqlite_pools.read().await;
                let pool = pools.get(id)
                    .ok_or_else(|| AppError::ConnectionNotFound(id.to_string()))?;
                sqlx::query("SELECT 1").execute(pool).await?;
            }
        }

        Ok(())
    }

    /// åˆ é™¤è¿æ¥
    pub async fn remove_connection(&self, id: &str) -> Result<(), AppError> {
        let config = {
            let configs = self.configs.read().await;
            configs.get(id).cloned()
        };

        let config = config.ok_or_else(|| AppError::ConnectionNotFound(id.to_string()))?;

        match config.db_type {
            DbType::MySQL => { self.mysql_pools.write().await.remove(id); }
            DbType::Postgres => { self.postgres_pools.write().await.remove(id); }
            DbType::SQLite => { self.sqlite_pools.write().await.remove(id); }
        }

        self.configs.write().await.remove(id);
        Ok(())
    }

    /// è·å–æ‰€æœ‰è¿æ¥é…ç½®
    pub async fn list_connections(&self) -> Vec<ConnectionConfig> {
        self.configs.read().await.values().cloned().collect()
    }

    /// è·å–å•ä¸ªè¿æ¥é…ç½®
    pub async fn get_connection(&self, id: &str) -> Option<ConnectionConfig> {
        self.configs.read().await.get(id).cloned()
    }

    /// æ‰§è¡ŒæŸ¥è¯¢
    pub async fn execute_query(
        &self,
        id: &str,
        sql: &str,
        limit: usize,
    ) -> Result<QueryResult, AppError> {
        let configs = self.configs.read().await;
        let config = configs.get(id)
            .ok_or_else(|| AppError::ConnectionNotFound(id.to_string()))?;
        let db_type = config.db_type.clone();
        drop(configs);

        match db_type {
            DbType::MySQL => self.execute_mysql_query(id, sql, limit).await,
            DbType::Postgres => self.execute_postgres_query(id, sql, limit).await,
            DbType::SQLite => self.execute_sqlite_query(id, sql, limit).await,
        }
    }

    /// æŒä¹…åŒ–é…ç½®åˆ°ç£ç›˜
    pub async fn save_to_disk(&self) -> Result<(), AppError> {
        let configs: Vec<_> = self.configs.read().await.values().cloned().collect();
        let path = self.config_file_path();

        tokio::fs::create_dir_all(path.parent().unwrap()).await
            .map_err(|e| AppError::Internal(e.to_string()))?;

        let json = serde_json::to_string_pretty(&configs)
            .map_err(|e| AppError::Internal(e.to_string()))?;

        tokio::fs::write(&path, json).await
            .map_err(|e| AppError::Internal(e.to_string()))?;

        tracing::debug!(path = %path.display(), "é…ç½®å·²ä¿å­˜");
        Ok(())
    }

    /// ä»ç£ç›˜åŠ è½½é…ç½®
    pub async fn load_from_disk(&self) -> Result<(), AppError> {
        let path = self.config_file_path();

        if !path.exists() {
            tracing::info!("é…ç½®æ–‡ä»¶ä¸å­˜åœ¨ï¼Œè·³è¿‡åŠ è½½");
            return Ok(());
        }

        let json = tokio::fs::read_to_string(&path).await
            .map_err(|e| AppError::Internal(e.to_string()))?;

        let configs: Vec<ConnectionConfig> = serde_json::from_str(&json)
            .map_err(|e| AppError::Internal(e.to_string()))?;

        for config in configs {
            if let Err(e) = self.add_connection(config.clone()).await {
                tracing::warn!(id = %config.id, error = %e, "åŠ è½½è¿æ¥å¤±è´¥");
            }
        }

        tracing::info!(path = %path.display(), "é…ç½®åŠ è½½å®Œæˆ");
        Ok(())
    }

    fn config_file_path(&self) -> PathBuf {
        PathBuf::from(&self.config.data_dir).join("connections.json")
    }

    fn build_mysql_url(&self, config: &ConnectionConfig) -> String {
        format!(
            "mysql://{}:{}@{}:{}/{}",
            config.username.as_deref().unwrap_or("root"),
            config.password.as_deref().unwrap_or(""),
            config.host.as_deref().unwrap_or("localhost"),
            config.port.unwrap_or(3306),
            config.database.as_deref().unwrap_or("")
        )
    }

    fn build_postgres_url(&self, config: &ConnectionConfig) -> String {
        format!(
            "postgres://{}:{}@{}:{}/{}",
            config.username.as_deref().unwrap_or("postgres"),
            config.password.as_deref().unwrap_or(""),
            config.host.as_deref().unwrap_or("localhost"),
            config.port.unwrap_or(5432),
            config.database.as_deref().unwrap_or("postgres")
        )
    }

    // MySQL æŸ¥è¯¢æ‰§è¡Œ
    async fn execute_mysql_query(&self, id: &str, sql: &str, limit: usize) -> Result<QueryResult, AppError> {
        let pools = self.mysql_pools.read().await;
        let pool = pools.get(id)
            .ok_or_else(|| AppError::ConnectionNotFound(id.to_string()))?;

        // ç®€åŒ–å®ç°ï¼Œå®é™…éœ€è¦æ›´å¤æ‚çš„ç»“æœè§£æ
        let rows: Vec<sqlx::mysql::MySqlRow> = sqlx::query(sql)
            .fetch_all(pool)
            .await?;

        // TODO: è§£æåˆ—ä¿¡æ¯å’Œè¡Œæ•°æ®
        Ok(QueryResult {
            columns: vec![],
            rows: vec![],
            row_count: rows.len().min(limit),
            affected_rows: None,
            execution_time_ms: 0,
        })
    }

    // PostgreSQL å’Œ SQLite ç±»ä¼¼å®ç°...
    async fn execute_postgres_query(&self, id: &str, sql: &str, limit: usize) -> Result<QueryResult, AppError> {
        // ç±»ä¼¼ MySQL å®ç°
        todo!()
    }

    async fn execute_sqlite_query(&self, id: &str, sql: &str, limit: usize) -> Result<QueryResult, AppError> {
        // ç±»ä¼¼ MySQL å®ç°
        todo!()
    }
}
```

---

## 8. ç»Ÿä¸€é”™è¯¯å¤„ç†

### 8.1 AppError (errors/app_error.rs)

```rust
use axum::{
    http::StatusCode,
    response::{IntoResponse, Response},
    Json,
};
use serde_json::json;
use thiserror::Error;

#[derive(Error, Debug)]
pub enum AppError {
    #[error("æ•°æ®åº“è¿æ¥å¤±è´¥: {0}")]
    DatabaseConnection(#[from] sqlx::Error),

    #[error("è¿æ¥ä¸å­˜åœ¨: {0}")]
    ConnectionNotFound(String),

    #[error("å‚æ•°éªŒè¯å¤±è´¥: {0}")]
    Validation(String),

    #[error("SQL ä¸å®‰å…¨: {0}")]
    UnsafeSql(String),

    #[error("æœªæˆæƒ")]
    Unauthorized,

    #[error("å†…éƒ¨é”™è¯¯: {0}")]
    Internal(String),
}

impl AppError {
    fn error_code(&self) -> &'static str {
        match self {
            AppError::DatabaseConnection(_) => "DATABASE_ERROR",
            AppError::ConnectionNotFound(_) => "CONNECTION_NOT_FOUND",
            AppError::Validation(_) => "VALIDATION_ERROR",
            AppError::UnsafeSql(_) => "UNSAFE_SQL",
            AppError::Unauthorized => "UNAUTHORIZED",
            AppError::Internal(_) => "INTERNAL_ERROR",
        }
    }

    fn status_code(&self) -> StatusCode {
        match self {
            AppError::DatabaseConnection(_) => StatusCode::BAD_GATEWAY,
            AppError::ConnectionNotFound(_) => StatusCode::NOT_FOUND,
            AppError::Validation(_) => StatusCode::BAD_REQUEST,
            AppError::UnsafeSql(_) => StatusCode::BAD_REQUEST,
            AppError::Unauthorized => StatusCode::UNAUTHORIZED,
            AppError::Internal(_) => StatusCode::INTERNAL_SERVER_ERROR,
        }
    }
}

impl IntoResponse for AppError {
    fn into_response(self) -> Response {
        // å†…éƒ¨é”™è¯¯ä¸æš´éœ²è¯¦ç»†ä¿¡æ¯
        let message = match &self {
            AppError::Internal(_) => "æœåŠ¡å™¨å†…éƒ¨é”™è¯¯".to_string(),
            e => e.to_string(),
        };

        // è®°å½•é”™è¯¯æ—¥å¿—
        match &self {
            AppError::Internal(msg) => tracing::error!(error = %msg, "å†…éƒ¨é”™è¯¯"),
            AppError::DatabaseConnection(e) => tracing::warn!(error = %e, "æ•°æ®åº“è¿æ¥é”™è¯¯"),
            _ => tracing::debug!(error = %self, "ä¸šåŠ¡é”™è¯¯"),
        }

        let body = Json(json!({
            "success": false,
            "error": {
                "code": self.error_code(),
                "message": message
            }
        }));

        (self.status_code(), body).into_response()
    }
}
```

---

## 9. API æ¥å£è®¾è®¡

### 9.1 æ¥å£æ¸…å•

| åŠŸèƒ½ | æ–¹æ³• | è·¯å¾„ | è¯·æ±‚ä½“ | å“åº” |
|------|------|------|--------|------|
| å¥åº·æ£€æŸ¥ | GET | `/api/health` | - | `HealthResponse` |
| å°±ç»ªæ£€æŸ¥ | GET | `/api/health/ready` | - | `{ ready: bool }` |
| å­˜æ´»æ£€æŸ¥ | GET | `/api/health/live` | - | `{ live: bool }` |
| è·å–æ‰€æœ‰è¿æ¥ | GET | `/api/connections` | - | `ConnectionConfig[]` |
| è·å–å•ä¸ªè¿æ¥ | GET | `/api/connections/:id` | - | `ConnectionConfig` |
| æ–°å»ºè¿æ¥ | POST | `/api/connections` | `CreateConnectionRequest` | `ConnectionConfig` |
| åˆ é™¤è¿æ¥ | DELETE | `/api/connections/:id` | - | `{ success: true }` |
| æµ‹è¯•è¿æ¥ | POST | `/api/connections/:id/test` | - | `ConnectionStatus` |
| æ‰§è¡Œ SQL | POST | `/api/connections/:id/query` | `QueryRequest` | `QueryResult` |

### 9.2 è¯·æ±‚/å“åº”ç¤ºä¾‹

#### å¥åº·æ£€æŸ¥
```http
GET /api/health

Response 200:
{
  "status": "healthy",
  "version": "0.1.0",
  "uptime_secs": 3600,
  "connections_count": 5,
  "timestamp": "2026-02-07T10:30:45.123Z"
}
```

#### æ–°å»ºè¿æ¥
```http
POST /api/connections
Content-Type: application/json

{
  "name": "ç”Ÿäº§æ•°æ®åº“",
  "type": "mysql",
  "host": "192.168.1.100",
  "port": 3306,
  "username": "admin",
  "password": "secret",
  "database": "production"
}

Response 201:
{
  "success": true,
  "data": {
    "id": "550e8400-e29b-41d4-a716-446655440000",
    "name": "ç”Ÿäº§æ•°æ®åº“",
    "type": "mysql",
    "host": "192.168.1.100",
    "port": 3306,
    "username": "admin",
    "database": "production",
    "created_at": "2026-02-07T10:30:45.123Z"
  }
}
```

#### æµ‹è¯•è¿æ¥
```http
POST /api/connections/550e8400-e29b-41d4-a716-446655440000/test

Response 200:
{
  "success": true,
  "data": {
    "id": "550e8400-e29b-41d4-a716-446655440000",
    "name": "ç”Ÿäº§æ•°æ®åº“",
    "db_type": "mysql",
    "is_connected": true,
    "latency_ms": 12
  }
}
```

#### æ‰§è¡Œ SQL
```http
POST /api/connections/550e8400-e29b-41d4-a716-446655440000/query
Content-Type: application/json

{
  "sql": "SELECT id, name, email FROM users WHERE active = true LIMIT 10",
  "limit": 100
}

Response 200:
{
  "success": true,
  "data": {
    "columns": [
      { "name": "id", "data_type": "INT" },
      { "name": "name", "data_type": "VARCHAR" },
      { "name": "email", "data_type": "VARCHAR" }
    ],
    "rows": [
      [1, "Alice", "alice@example.com"],
      [2, "Bob", "bob@example.com"]
    ],
    "row_count": 2,
    "execution_time_ms": 15
  }
}
```

#### é”™è¯¯å“åº”
```http
POST /api/connections/invalid-id/test

Response 404:
{
  "success": false,
  "error": {
    "code": "CONNECTION_NOT_FOUND",
    "message": "è¿æ¥ä¸å­˜åœ¨: invalid-id"
  }
}
```

---

## 10. AI æ™ºèƒ½åŠŸèƒ½

### 10.1 åŠŸèƒ½æ¦‚è§ˆ

| åŠŸèƒ½ | æè¿° | ä¼˜å…ˆçº§ |
|------|------|--------|
| è‡ªç„¶è¯­è¨€è½¬ SQL | ç”¨ä¸­æ–‡æè¿°éœ€æ±‚ï¼ŒAI ç”Ÿæˆ SQL | ğŸ”´ é«˜ |
| SQL æ™ºèƒ½ä¼˜åŒ– | åˆ†æ SQL æ€§èƒ½ï¼Œç»™å‡ºä¼˜åŒ–å»ºè®® | ğŸŸ  ä¸­ |
| æŸ¥è¯¢ç»“æœåˆ†æ | è‡ªåŠ¨åˆ†ææ•°æ®ï¼Œç”Ÿæˆæ´å¯Ÿæ‘˜è¦ | ğŸŸ  ä¸­ |
| æ™ºèƒ½é—®ç­” | åŸºäºæ•°æ®åº“å†…å®¹å›ç­”ä¸šåŠ¡é—®é¢˜ | ğŸŸ¡ ä½ |

### 10.2 ç³»ç»Ÿæ¶æ„

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                         ç”¨æˆ·è¯·æ±‚                                 â”‚
â”‚  "æŸ¥è¯¢æœ€è¿‘7å¤©æ³¨å†Œä¸”æ¶ˆè´¹è¶…è¿‡100å…ƒçš„ç”¨æˆ·"                            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      AI æœåŠ¡å±‚ (AiService)                       â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚ Text2SqlService â”‚  â”‚ SqlOptimizer    â”‚  â”‚ DataAnalyzer    â”‚  â”‚
â”‚  â”‚ è‡ªç„¶è¯­è¨€ â†’ SQL   â”‚  â”‚ SQL ä¼˜åŒ–å»ºè®®    â”‚  â”‚ ç»“æœåˆ†ææ´å¯Ÿ    â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
            â–¼                    â–¼                    â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                     LLM é€‚é…å±‚ (LlmClient)                       â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚ Claude API      â”‚  â”‚ OpenAI API      â”‚  â”‚ æœ¬åœ°æ¨¡å‹ (å¯é€‰)  â”‚  â”‚
â”‚  â”‚ (æ¨è)          â”‚  â”‚                 â”‚  â”‚ Ollama/vLLM     â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
            â”‚
            â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                     Schema ç®¡ç†å™¨                                â”‚
â”‚  - è·å–è¡¨ç»“æ„                                                    â”‚
â”‚  - æ„å»ºä¸Šä¸‹æ–‡ Prompt                                             â”‚
â”‚  - ç¼“å­˜ Schema ä¿¡æ¯                                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 10.3 æ¨¡å—ç»“æ„

```text
src/
â”œâ”€â”€ ai/                           # AI åŠŸèƒ½æ¨¡å—
â”‚   â”œâ”€â”€ mod.rs                    # æ¨¡å—å…¥å£
â”‚   â”œâ”€â”€ llm_client.rs             # LLM API å®¢æˆ·ç«¯
â”‚   â”œâ”€â”€ text2sql.rs               # è‡ªç„¶è¯­è¨€è½¬ SQL
â”‚   â”œâ”€â”€ sql_optimizer.rs          # SQL ä¼˜åŒ–å»ºè®®
â”‚   â”œâ”€â”€ data_analyzer.rs          # æ•°æ®åˆ†æ
â”‚   â”œâ”€â”€ schema_manager.rs         # Schema ç®¡ç†
â”‚   â””â”€â”€ prompt_templates.rs       # Prompt æ¨¡æ¿
```

### 10.4 LLM å®¢æˆ·ç«¯è®¾è®¡ (ai/llm_client.rs)

```rust
use async_trait::async_trait;
use serde::{Deserialize, Serialize};

/// LLM æä¾›å•†é…ç½®
#[derive(Debug, Clone, Deserialize)]
pub struct LlmConfig {
    pub provider: LlmProvider,
    pub api_key: String,
    pub model: String,
    pub base_url: Option<String>,
    pub max_tokens: u32,
    pub temperature: f32,
}

#[derive(Debug, Clone, Deserialize)]
#[serde(rename_all = "lowercase")]
pub enum LlmProvider {
    Claude,
    OpenAI,
    Ollama,
}

/// LLM è¯·æ±‚æ¶ˆæ¯
#[derive(Debug, Serialize)]
pub struct ChatMessage {
    pub role: String,       // "system" | "user" | "assistant"
    pub content: String,
}

/// LLM å“åº”
#[derive(Debug, Deserialize)]
pub struct ChatResponse {
    pub content: String,
    pub usage: TokenUsage,
}

#[derive(Debug, Deserialize)]
pub struct TokenUsage {
    pub input_tokens: u32,
    pub output_tokens: u32,
}

/// LLM å®¢æˆ·ç«¯ trait
#[async_trait]
pub trait LlmClient: Send + Sync {
    async fn chat(&self, messages: Vec<ChatMessage>) -> Result<ChatResponse, AppError>;
}

/// Claude API å®¢æˆ·ç«¯
pub struct ClaudeClient {
    config: LlmConfig,
    client: reqwest::Client,
}

impl ClaudeClient {
    pub fn new(config: LlmConfig) -> Self {
        Self {
            config,
            client: reqwest::Client::new(),
        }
    }
}

#[async_trait]
impl LlmClient for ClaudeClient {
    async fn chat(&self, messages: Vec<ChatMessage>) -> Result<ChatResponse, AppError> {
        let url = self.config.base_url.as_deref()
            .unwrap_or("https://api.anthropic.com/v1/messages");

        let system = messages.iter()
            .find(|m| m.role == "system")
            .map(|m| m.content.clone());

        let user_messages: Vec<_> = messages.iter()
            .filter(|m| m.role != "system")
            .map(|m| serde_json::json!({
                "role": m.role,
                "content": m.content
            }))
            .collect();

        let mut body = serde_json::json!({
            "model": self.config.model,
            "max_tokens": self.config.max_tokens,
            "messages": user_messages
        });

        if let Some(sys) = system {
            body["system"] = serde_json::json!(sys);
        }

        let response = self.client
            .post(url)
            .header("x-api-key", &self.config.api_key)
            .header("anthropic-version", "2023-06-01")
            .header("content-type", "application/json")
            .json(&body)
            .send()
            .await
            .map_err(|e| AppError::Internal(e.to_string()))?;

        let result: serde_json::Value = response.json().await
            .map_err(|e| AppError::Internal(e.to_string()))?;

        Ok(ChatResponse {
            content: result["content"][0]["text"].as_str().unwrap_or("").to_string(),
            usage: TokenUsage {
                input_tokens: result["usage"]["input_tokens"].as_u64().unwrap_or(0) as u32,
                output_tokens: result["usage"]["output_tokens"].as_u64().unwrap_or(0) as u32,
            },
        })
    }
}

/// åˆ›å»º LLM å®¢æˆ·ç«¯å·¥å‚
pub fn create_llm_client(config: LlmConfig) -> Box<dyn LlmClient> {
    match config.provider {
        LlmProvider::Claude => Box::new(ClaudeClient::new(config)),
        LlmProvider::OpenAI => Box::new(OpenAIClient::new(config)),
        LlmProvider::Ollama => Box::new(OllamaClient::new(config)),
    }
}
```

### 10.5 è‡ªç„¶è¯­è¨€è½¬ SQL (ai/text2sql.rs)

```rust
use crate::ai::{LlmClient, ChatMessage};
use crate::models::connection::DbType;

pub struct Text2SqlService {
    llm_client: Box<dyn LlmClient>,
    schema_manager: Arc<SchemaManager>,
}

/// Text2SQL è¯·æ±‚
#[derive(Debug, Deserialize)]
pub struct Text2SqlRequest {
    /// è‡ªç„¶è¯­è¨€æè¿°
    pub question: String,
    /// ç›®æ ‡æ•°æ®åº“è¿æ¥ ID
    pub connection_id: String,
    /// æ˜¯å¦è‡ªåŠ¨æ‰§è¡Œ
    #[serde(default)]
    pub auto_execute: bool,
}

/// Text2SQL å“åº”
#[derive(Debug, Serialize)]
pub struct Text2SqlResponse {
    /// ç”Ÿæˆçš„ SQL
    pub sql: String,
    /// SQL è§£é‡Š
    pub explanation: String,
    /// ç½®ä¿¡åº¦ (0-1)
    pub confidence: f32,
    /// æ‰§è¡Œç»“æœï¼ˆå¦‚æœ auto_execute=trueï¼‰
    #[serde(skip_serializing_if = "Option::is_none")]
    pub result: Option<QueryResult>,
    /// è­¦å‘Šä¿¡æ¯
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub warnings: Vec<String>,
}

impl Text2SqlService {
    pub fn new(llm_client: Box<dyn LlmClient>, schema_manager: Arc<SchemaManager>) -> Self {
        Self { llm_client, schema_manager }
    }

    /// å°†è‡ªç„¶è¯­è¨€è½¬æ¢ä¸º SQL
    pub async fn generate_sql(&self, req: &Text2SqlRequest) -> Result<Text2SqlResponse, AppError> {
        // 1. è·å–æ•°æ®åº“ Schema
        let schema = self.schema_manager
            .get_schema(&req.connection_id)
            .await?;

        // 2. æ„å»º Prompt
        let messages = self.build_prompt(&req.question, &schema);

        // 3. è°ƒç”¨ LLM
        let response = self.llm_client.chat(messages).await?;

        // 4. è§£æå“åº”
        let parsed = self.parse_response(&response.content)?;

        // 5. SQL å®‰å…¨æ£€æŸ¥
        let warnings = self.validate_sql(&parsed.sql)?;

        Ok(Text2SqlResponse {
            sql: parsed.sql,
            explanation: parsed.explanation,
            confidence: parsed.confidence,
            result: None,
            warnings,
        })
    }

    fn build_prompt(&self, question: &str, schema: &DatabaseSchema) -> Vec<ChatMessage> {
        let system_prompt = format!(r#"
ä½ æ˜¯ä¸€ä¸ªä¸“ä¸šçš„ SQL ä¸“å®¶ã€‚æ ¹æ®ç”¨æˆ·çš„è‡ªç„¶è¯­è¨€æè¿°ç”Ÿæˆå‡†ç¡®çš„ SQL æŸ¥è¯¢ã€‚

## æ•°æ®åº“ä¿¡æ¯
- æ•°æ®åº“ç±»å‹: {db_type}
- è¡¨ç»“æ„:
{schema}

## è§„åˆ™
1. åªç”Ÿæˆ SELECT æŸ¥è¯¢ï¼Œç¦æ­¢ INSERT/UPDATE/DELETE/DROP
2. ä½¿ç”¨æ ‡å‡† SQL è¯­æ³•
3. æ·»åŠ åˆç†çš„ LIMIT é™åˆ¶ï¼ˆé»˜è®¤ 100ï¼‰
4. å¯¹äºæ¨¡ç³ŠæŸ¥è¯¢ä½¿ç”¨ LIKE
5. æ—¥æœŸä½¿ç”¨æ ‡å‡†æ ¼å¼

## è¾“å‡ºæ ¼å¼
```json
{{
  "sql": "ç”Ÿæˆçš„ SQL è¯­å¥",
  "explanation": "SQL çš„ä¸­æ–‡è§£é‡Š",
  "confidence": 0.95
}}
```
"#,
            db_type = schema.db_type,
            schema = schema.to_prompt_string()
        );

        vec![
            ChatMessage {
                role: "system".into(),
                content: system_prompt,
            },
            ChatMessage {
                role: "user".into(),
                content: question.to_string(),
            },
        ]
    }

    fn validate_sql(&self, sql: &str) -> Result<Vec<String>, AppError> {
        let mut warnings = Vec::new();
        let sql_upper = sql.to_uppercase();

        // æ£€æŸ¥å±é™©æ“ä½œ
        if sql_upper.contains("DROP") || sql_upper.contains("DELETE") || sql_upper.contains("TRUNCATE") {
            return Err(AppError::UnsafeSql("AI ç”Ÿæˆäº†å±é™©çš„ SQL æ“ä½œ".into()));
        }

        // æ£€æŸ¥æ˜¯å¦ç¼ºå°‘ LIMIT
        if sql_upper.contains("SELECT") && !sql_upper.contains("LIMIT") {
            warnings.push("å»ºè®®æ·»åŠ  LIMIT é™åˆ¶è¿”å›è¡Œæ•°".into());
        }

        Ok(warnings)
    }
}
```

### 10.6 Schema ç®¡ç†å™¨ (ai/schema_manager.rs)

```rust
use std::collections::HashMap;
use tokio::sync::RwLock;

/// æ•°æ®åº“ Schema ä¿¡æ¯
#[derive(Debug, Clone, Serialize)]
pub struct DatabaseSchema {
    pub db_type: DbType,
    pub tables: Vec<TableSchema>,
    pub updated_at: chrono::DateTime<chrono::Utc>,
}

#[derive(Debug, Clone, Serialize)]
pub struct TableSchema {
    pub name: String,
    pub comment: Option<String>,
    pub columns: Vec<ColumnSchema>,
}

#[derive(Debug, Clone, Serialize)]
pub struct ColumnSchema {
    pub name: String,
    pub data_type: String,
    pub nullable: bool,
    pub primary_key: bool,
    pub comment: Option<String>,
}

impl DatabaseSchema {
    /// è½¬æ¢ä¸º Prompt å‹å¥½çš„å­—ç¬¦ä¸²
    pub fn to_prompt_string(&self) -> String {
        let mut result = String::new();
        for table in &self.tables {
            result.push_str(&format!("### è¡¨: {}\n", table.name));
            if let Some(comment) = &table.comment {
                result.push_str(&format!("è¯´æ˜: {}\n", comment));
            }
            result.push_str("| åˆ—å | ç±»å‹ | å¯ç©º | è¯´æ˜ |\n");
            result.push_str("|------|------|------|------|\n");
            for col in &table.columns {
                result.push_str(&format!(
                    "| {} | {} | {} | {} |\n",
                    col.name,
                    col.data_type,
                    if col.nullable { "æ˜¯" } else { "å¦" },
                    col.comment.as_deref().unwrap_or("-")
                ));
            }
            result.push('\n');
        }
        result
    }
}

pub struct SchemaManager {
    pool_manager: Arc<PoolManager>,
    cache: RwLock<HashMap<String, DatabaseSchema>>,
    cache_ttl: std::time::Duration,
}

impl SchemaManager {
    pub fn new(pool_manager: Arc<PoolManager>) -> Self {
        Self {
            pool_manager,
            cache: RwLock::new(HashMap::new()),
            cache_ttl: std::time::Duration::from_secs(300), // 5åˆ†é’Ÿç¼“å­˜
        }
    }

    /// è·å–æ•°æ®åº“ Schemaï¼ˆå¸¦ç¼“å­˜ï¼‰
    pub async fn get_schema(&self, connection_id: &str) -> Result<DatabaseSchema, AppError> {
        // æ£€æŸ¥ç¼“å­˜
        {
            let cache = self.cache.read().await;
            if let Some(schema) = cache.get(connection_id) {
                if schema.updated_at + chrono::Duration::from_std(self.cache_ttl).unwrap() > chrono::Utc::now() {
                    return Ok(schema.clone());
                }
            }
        }

        // åˆ·æ–° Schema
        let schema = self.fetch_schema(connection_id).await?;
        self.cache.write().await.insert(connection_id.to_string(), schema.clone());
        Ok(schema)
    }

    /// ä»æ•°æ®åº“è·å– Schema
    async fn fetch_schema(&self, connection_id: &str) -> Result<DatabaseSchema, AppError> {
        let config = self.pool_manager.get_connection(connection_id).await
            .ok_or_else(|| AppError::ConnectionNotFound(connection_id.to_string()))?;

        let tables = match config.db_type {
            DbType::MySQL => self.fetch_mysql_schema(connection_id).await?,
            DbType::Postgres => self.fetch_postgres_schema(connection_id).await?,
            DbType::SQLite => self.fetch_sqlite_schema(connection_id).await?,
        };

        Ok(DatabaseSchema {
            db_type: config.db_type,
            tables,
            updated_at: chrono::Utc::now(),
        })
    }

    async fn fetch_mysql_schema(&self, connection_id: &str) -> Result<Vec<TableSchema>, AppError> {
        // æŸ¥è¯¢ information_schema è·å–è¡¨å’Œåˆ—ä¿¡æ¯
        let sql = r#"
            SELECT
                t.TABLE_NAME,
                t.TABLE_COMMENT,
                c.COLUMN_NAME,
                c.DATA_TYPE,
                c.IS_NULLABLE,
                c.COLUMN_KEY,
                c.COLUMN_COMMENT
            FROM information_schema.TABLES t
            JOIN information_schema.COLUMNS c
                ON t.TABLE_SCHEMA = c.TABLE_SCHEMA
                AND t.TABLE_NAME = c.TABLE_NAME
            WHERE t.TABLE_SCHEMA = DATABASE()
            ORDER BY t.TABLE_NAME, c.ORDINAL_POSITION
        "#;
        // ... æ‰§è¡ŒæŸ¥è¯¢å¹¶è§£æç»“æœ
        todo!()
    }
}
```

### 10.7 SQL ä¼˜åŒ–å»ºè®® (ai/sql_optimizer.rs)

```rust
pub struct SqlOptimizer {
    llm_client: Box<dyn LlmClient>,
}

#[derive(Debug, Deserialize)]
pub struct OptimizeRequest {
    pub sql: String,
    pub connection_id: String,
}

#[derive(Debug, Serialize)]
pub struct OptimizeResponse {
    /// ä¼˜åŒ–åçš„ SQL
    pub optimized_sql: String,
    /// ä¼˜åŒ–å»ºè®®åˆ—è¡¨
    pub suggestions: Vec<OptimizationSuggestion>,
    /// é¢„ä¼°æ€§èƒ½æå‡
    pub estimated_improvement: Option<String>,
}

#[derive(Debug, Serialize)]
pub struct OptimizationSuggestion {
    pub category: String,       // "index" | "rewrite" | "structure"
    pub description: String,
    pub severity: String,       // "low" | "medium" | "high"
}

impl SqlOptimizer {
    pub async fn optimize(&self, req: &OptimizeRequest) -> Result<OptimizeResponse, AppError> {
        let messages = vec![
            ChatMessage {
                role: "system".into(),
                content: r#"
ä½ æ˜¯ SQL æ€§èƒ½ä¼˜åŒ–ä¸“å®¶ã€‚åˆ†æç»™å®šçš„ SQL å¹¶æä¾›ä¼˜åŒ–å»ºè®®ã€‚

## åˆ†æç»´åº¦
1. ç´¢å¼•ä½¿ç”¨ï¼šæ˜¯å¦æœ‰å…¨è¡¨æ‰«æã€ç¼ºå°‘ç´¢å¼•
2. æŸ¥è¯¢é‡å†™ï¼šå­æŸ¥è¯¢ä¼˜åŒ–ã€JOIN é¡ºåº
3. æ•°æ®ç±»å‹ï¼šéšå¼è½¬æ¢é—®é¢˜
4. åˆ†é¡µä¼˜åŒ–ï¼šå¤§åç§»é‡é—®é¢˜

## è¾“å‡ºæ ¼å¼
```json
{
  "optimized_sql": "ä¼˜åŒ–åçš„ SQL",
  "suggestions": [
    {
      "category": "index",
      "description": "å»ºè®®åœ¨ users.email åˆ—æ·»åŠ ç´¢å¼•",
      "severity": "high"
    }
  ],
  "estimated_improvement": "é¢„è®¡æå‡ 50% æŸ¥è¯¢é€Ÿåº¦"
}
```
"#.into(),
            },
            ChatMessage {
                role: "user".into(),
                content: format!("è¯·åˆ†æå¹¶ä¼˜åŒ–ä»¥ä¸‹ SQL:\n```sql\n{}\n```", req.sql),
            },
        ];

        let response = self.llm_client.chat(messages).await?;
        serde_json::from_str(&response.content)
            .map_err(|e| AppError::Internal(format!("è§£æ AI å“åº”å¤±è´¥: {}", e)))
    }
}
```

### 10.8 æ•°æ®åˆ†ææœåŠ¡ (ai/data_analyzer.rs)

```rust
pub struct DataAnalyzer {
    llm_client: Box<dyn LlmClient>,
}

#[derive(Debug, Deserialize)]
pub struct AnalyzeRequest {
    /// æŸ¥è¯¢ç»“æœæ•°æ®
    pub data: QueryResult,
    /// åˆ†æç±»å‹
    pub analysis_type: AnalysisType,
    /// ç”¨æˆ·é—®é¢˜ï¼ˆå¯é€‰ï¼‰
    pub question: Option<String>,
}

#[derive(Debug, Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum AnalysisType {
    Summary,        // æ•°æ®æ‘˜è¦
    Trend,          // è¶‹åŠ¿åˆ†æ
    Anomaly,        // å¼‚å¸¸æ£€æµ‹
    Correlation,    // ç›¸å…³æ€§åˆ†æ
}

#[derive(Debug, Serialize)]
pub struct AnalysisResponse {
    /// åˆ†ææ‘˜è¦
    pub summary: String,
    /// å…³é”®æ´å¯Ÿ
    pub insights: Vec<Insight>,
    /// å»ºè®®çš„åç»­æŸ¥è¯¢
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub suggested_queries: Vec<SuggestedQuery>,
}

#[derive(Debug, Serialize)]
pub struct Insight {
    pub title: String,
    pub description: String,
    pub importance: String,  // "low" | "medium" | "high"
}

#[derive(Debug, Serialize)]
pub struct SuggestedQuery {
    pub description: String,
    pub sql: String,
}

impl DataAnalyzer {
    pub async fn analyze(&self, req: &AnalyzeRequest) -> Result<AnalysisResponse, AppError> {
        // å°†æ•°æ®è½¬æ¢ä¸º LLM å¯ç†è§£çš„æ ¼å¼
        let data_preview = self.format_data_preview(&req.data);

        let prompt = match req.analysis_type {
            AnalysisType::Summary => self.build_summary_prompt(&data_preview, &req.question),
            AnalysisType::Trend => self.build_trend_prompt(&data_preview),
            AnalysisType::Anomaly => self.build_anomaly_prompt(&data_preview),
            AnalysisType::Correlation => self.build_correlation_prompt(&data_preview),
        };

        let response = self.llm_client.chat(prompt).await?;
        serde_json::from_str(&response.content)
            .map_err(|e| AppError::Internal(format!("è§£æåˆ†æç»“æœå¤±è´¥: {}", e)))
    }

    fn format_data_preview(&self, data: &QueryResult) -> String {
        // æ ¼å¼åŒ–æ•°æ®é¢„è§ˆï¼ˆé™åˆ¶è¡Œæ•°é¿å… token è¿‡å¤šï¼‰
        let max_rows = 50;
        let mut result = String::new();

        // åˆ—å
        let headers: Vec<_> = data.columns.iter().map(|c| c.name.as_str()).collect();
        result.push_str(&format!("| {} |\n", headers.join(" | ")));
        result.push_str(&format!("| {} |\n", headers.iter().map(|_| "---").collect::<Vec<_>>().join(" | ")));

        // æ•°æ®è¡Œ
        for (i, row) in data.rows.iter().enumerate() {
            if i >= max_rows {
                result.push_str(&format!("\n... è¿˜æœ‰ {} è¡Œæ•°æ® ...\n", data.rows.len() - max_rows));
                break;
            }
            let values: Vec<_> = row.iter().map(|v| v.to_string()).collect();
            result.push_str(&format!("| {} |\n", values.join(" | ")));
        }

        result
    }
}
```

### 10.9 AI API æ¥å£

| åŠŸèƒ½ | æ–¹æ³• | è·¯å¾„ | è¯·æ±‚ä½“ | å“åº” |
|------|------|------|--------|------|
| è‡ªç„¶è¯­è¨€è½¬ SQL | POST | `/api/ai/text2sql` | `Text2SqlRequest` | `Text2SqlResponse` |
| SQL ä¼˜åŒ–å»ºè®® | POST | `/api/ai/optimize` | `OptimizeRequest` | `OptimizeResponse` |
| æ•°æ®åˆ†æ | POST | `/api/ai/analyze` | `AnalyzeRequest` | `AnalysisResponse` |
| æ™ºèƒ½é—®ç­” | POST | `/api/ai/chat` | `ChatRequest` | `ChatResponse` |

#### è‡ªç„¶è¯­è¨€è½¬ SQL ç¤ºä¾‹

```http
POST /api/ai/text2sql
Content-Type: application/json

{
  "question": "æŸ¥è¯¢æœ€è¿‘7å¤©æ³¨å†Œä¸”æ¶ˆè´¹è¶…è¿‡100å…ƒçš„ç”¨æˆ·",
  "connection_id": "550e8400-e29b-41d4-a716-446655440000",
  "auto_execute": false
}

Response 200:
{
  "success": true,
  "data": {
    "sql": "SELECT u.id, u.name, u.email, SUM(o.amount) as total_spent\nFROM users u\nJOIN orders o ON u.id = o.user_id\nWHERE u.created_at >= DATE_SUB(NOW(), INTERVAL 7 DAY)\nGROUP BY u.id\nHAVING total_spent > 100\nLIMIT 100",
    "explanation": "æŸ¥è¯¢æœ€è¿‘7å¤©æ³¨å†Œçš„ç”¨æˆ·ï¼Œå¹¶å…³è”è®¢å•è¡¨è®¡ç®—æ¶ˆè´¹æ€»é¢ï¼Œç­›é€‰æ¶ˆè´¹è¶…è¿‡100å…ƒçš„ç”¨æˆ·",
    "confidence": 0.92,
    "warnings": []
  }
}
```

#### æ•°æ®åˆ†æç¤ºä¾‹

```http
POST /api/ai/analyze
Content-Type: application/json

{
  "data": {
    "columns": [{"name": "date", "data_type": "DATE"}, {"name": "sales", "data_type": "DECIMAL"}],
    "rows": [["2026-02-01", 1500], ["2026-02-02", 1800], ["2026-02-03", 1200], ...]
  },
  "analysis_type": "trend",
  "question": "é”€å”®è¶‹åŠ¿å¦‚ä½•ï¼Ÿ"
}

Response 200:
{
  "success": true,
  "data": {
    "summary": "è¿‡å»ä¸€å‘¨é”€å”®é¢æ•´ä½“å‘ˆä¸Šå‡è¶‹åŠ¿ï¼Œå¹³å‡æ—¥é”€å”®é¢ä¸º 1580 å…ƒ",
    "insights": [
      {
        "title": "å‘¨æœ«é”€å”®é«˜å³°",
        "description": "å‘¨å…­å’Œå‘¨æ—¥çš„é”€å”®é¢æ¯”å·¥ä½œæ—¥é«˜å‡ºçº¦ 30%",
        "importance": "high"
      },
      {
        "title": "å‘¨ä¸‰ä½è°·",
        "description": "å‘¨ä¸‰é”€å”®é¢æœ€ä½ï¼Œå»ºè®®è€ƒè™‘ä¿ƒé”€æ´»åŠ¨",
        "importance": "medium"
      }
    ],
    "suggested_queries": [
      {
        "description": "æŒ‰äº§å“ç±»åˆ«åˆ†æé”€å”®",
        "sql": "SELECT category, SUM(amount) FROM sales GROUP BY category"
      }
    ]
  }
}
```

### 10.10 AI é…ç½®

```rust
// config.rs æ–°å¢
#[derive(Debug, Clone, Deserialize)]
pub struct AiConfig {
    /// æ˜¯å¦å¯ç”¨ AI åŠŸèƒ½
    #[serde(default)]
    pub enabled: bool,

    /// LLM æä¾›å•†
    #[serde(default = "default_provider")]
    pub provider: String,

    /// API Key
    pub api_key: Option<String>,

    /// æ¨¡å‹åç§°
    #[serde(default = "default_model")]
    pub model: String,

    /// API åŸºç¡€ URLï¼ˆå¯é€‰ï¼Œç”¨äºè‡ªå®šä¹‰ç«¯ç‚¹ï¼‰
    pub base_url: Option<String>,

    /// æœ€å¤§ tokens
    #[serde(default = "default_max_tokens")]
    pub max_tokens: u32,

    /// æ¸©åº¦å‚æ•°
    #[serde(default = "default_temperature")]
    pub temperature: f32,
}

fn default_provider() -> String { "claude".into() }
fn default_model() -> String { "claude-sonnet-4-20250514".into() }
fn default_max_tokens() -> u32 { 4096 }
fn default_temperature() -> f32 { 0.1 }
```

### 10.11 ç¯å¢ƒå˜é‡

| å˜é‡å | é»˜è®¤å€¼ | è¯´æ˜ |
|--------|--------|------|
| `AI_ENABLED` | `false` | æ˜¯å¦å¯ç”¨ AI åŠŸèƒ½ |
| `AI_PROVIDER` | `claude` | LLM æä¾›å•† (claude/openai/ollama) |
| `AI_API_KEY` | - | API å¯†é’¥ |
| `AI_MODEL` | `claude-sonnet-4-20250514` | æ¨¡å‹åç§° |
| `AI_BASE_URL` | - | è‡ªå®šä¹‰ API ç«¯ç‚¹ |
| `AI_MAX_TOKENS` | `4096` | æœ€å¤§è¾“å‡º tokens |
| `AI_TEMPERATURE` | `0.1` | æ¸©åº¦å‚æ•° (0-1) |

---

## 11. ä¸­é—´ä»¶é…ç½®

### 10.1 ä¸­é—´ä»¶åˆ—è¡¨

| ä¸­é—´ä»¶ | åŠŸèƒ½ | è¯´æ˜ |
|--------|------|------|
| CorsLayer | è·¨åŸŸæ”¯æŒ | å…è®¸å‰ç«¯è·¨åŸŸè¯·æ±‚ |
| TraceLayer | è¯·æ±‚è¿½è¸ª | è®°å½•è¯·æ±‚æ–¹æ³•ã€è·¯å¾„ã€çŠ¶æ€ç ã€è€—æ—¶ |
| CompressionLayer | å“åº”å‹ç¼© | gzip/deflate/br å‹ç¼© |
| RequestIdLayer | è¯·æ±‚ ID | æ¯ä¸ªè¯·æ±‚åˆ†é…å”¯ä¸€ IDï¼ˆå¯é€‰ï¼‰ |
| AuthLayer | è®¤è¯ | API Key éªŒè¯ï¼ˆå¯é€‰ï¼‰ |

### 10.2 ç”Ÿäº§ç¯å¢ƒ CORS é…ç½®

```rust
use tower_http::cors::CorsLayer;
use http::{Method, header};

let cors = CorsLayer::new()
    .allow_origin([
        "https://your-frontend.com".parse().unwrap(),
        "https://admin.your-frontend.com".parse().unwrap(),
    ])
    .allow_methods([
        Method::GET,
        Method::POST,
        Method::DELETE,
        Method::OPTIONS,
    ])
    .allow_headers([
        header::CONTENT_TYPE,
        header::AUTHORIZATION,
        header::HeaderName::from_static("x-api-key"),
    ])
    .max_age(std::time::Duration::from_secs(3600));
```

---

## 11. é…ç½®æŒä¹…åŒ–

### 11.1 å­˜å‚¨æ–¹æ¡ˆ

è¿æ¥é…ç½®æŒä¹…åŒ–åˆ°æœ¬åœ° JSON æ–‡ä»¶ï¼š

```
data/
â””â”€â”€ connections.json    # è¿æ¥é…ç½®åˆ—è¡¨
```

### 11.2 æ–‡ä»¶æ ¼å¼

```json
[
  {
    "id": "550e8400-e29b-41d4-a716-446655440000",
    "name": "ç”Ÿäº§æ•°æ®åº“",
    "db_type": "mysql",
    "host": "192.168.1.100",
    "port": 3306,
    "username": "admin",
    "password": "encrypted:xxxxx",
    "database": "production",
    "created_at": "2026-02-07T10:30:45.123Z"
  }
]
```

### 11.3 å¯†ç åŠ å¯†ï¼ˆè§„åˆ’ä¸­ï¼‰

```rust
use aes_gcm::{Aes256Gcm, Key, Nonce};

pub fn encrypt_password(password: &str, key: &[u8]) -> String {
    // AES-256-GCM åŠ å¯†
    format!("encrypted:{}", base64_encoded_ciphertext)
}

pub fn decrypt_password(encrypted: &str, key: &[u8]) -> Result<String, Error> {
    // è§£å¯†
}
```

---

## 12. æ—¥å¿—è§„èŒƒ

### 12.1 æ—¥å¿—æ ¼å¼ (JSON)

```json
{
  "timestamp": "2026-02-07T10:30:45.123456Z",
  "level": "INFO",
  "target": "databasemanager::routes::connections",
  "message": "è¿æ¥åˆ›å»ºæˆåŠŸ",
  "span": {
    "request_id": "req-123",
    "method": "POST",
    "path": "/api/connections"
  },
  "fields": {
    "connection_id": "550e8400-...",
    "connection_name": "ç”Ÿäº§æ•°æ®åº“"
  }
}
```

### 12.2 æ—¥å¿—çº§åˆ«ä½¿ç”¨è§„èŒƒ

| çº§åˆ« | ä½¿ç”¨åœºæ™¯ |
|------|---------|
| ERROR | ç³»ç»Ÿé”™è¯¯ã€æ•°æ®åº“è¿æ¥å¤±è´¥ã€æœªå¤„ç†å¼‚å¸¸ |
| WARN | ä¸šåŠ¡è­¦å‘Šã€è¿æ¥è¶…æ—¶ã€é…ç½®ç¼ºå¤± |
| INFO | å…³é”®æ“ä½œã€æœåŠ¡å¯åŠ¨/å…³é—­ã€è¿æ¥åˆ›å»º/åˆ é™¤ |
| DEBUG | è°ƒè¯•ä¿¡æ¯ã€SQL è¯­å¥ã€è¯·æ±‚è¯¦æƒ… |
| TRACE | è¯¦ç»†è¿½è¸ªã€å‡½æ•°è°ƒç”¨ã€æ€§èƒ½åˆ†æ |

### 12.3 æ•æ„Ÿä¿¡æ¯è¿‡æ»¤

```rust
// å¯†ç ä¸è®°å½•åˆ°æ—¥å¿—
tracing::info!(
    connection_id = %config.id,
    host = %config.host.as_deref().unwrap_or(""),
    username = %config.username.as_deref().unwrap_or(""),
    // password ä¸è®°å½•
    "åˆ›å»ºæ•°æ®åº“è¿æ¥"
);
```

---

## 13. å®‰å…¨æ€§è®¾è®¡

### 13.1 å¯†ç å¤„ç†

- å“åº” JSON ä¸­ä¸è¿”å›å¯†ç ï¼ˆ`#[serde(skip_serializing)]`ï¼‰
- æ—¥å¿—ä¸­ä¸è®°å½•å¯†ç 
- æŒä¹…åŒ–æ—¶åŠ å¯†å­˜å‚¨ï¼ˆè§„åˆ’ä¸­ï¼‰

### 13.2 SQL æ³¨å…¥é˜²æŠ¤

```rust
// utils/sql_validator.rs
pub struct SqlValidator;

impl SqlValidator {
    /// æ£€æŸ¥ SQL æ˜¯å¦å®‰å…¨
    pub fn validate(sql: &str) -> Result<(), AppError> {
        let sql_upper = sql.to_uppercase();

        // ç¦æ­¢å±é™©æ“ä½œ
        let forbidden = ["DROP ", "TRUNCATE ", "DELETE FROM", "ALTER ", "GRANT ", "REVOKE "];
        for keyword in forbidden {
            if sql_upper.contains(keyword) {
                return Err(AppError::UnsafeSql(format!("ç¦æ­¢ä½¿ç”¨ {}", keyword.trim())));
            }
        }

        // ç¦æ­¢å¤šè¯­å¥
        if sql.contains(';') && sql.matches(';').count() > 1 {
            return Err(AppError::UnsafeSql("ç¦æ­¢å¤šè¯­å¥æ‰§è¡Œ".into()));
        }

        Ok(())
    }
}
```

### 13.3 è®¤è¯æœºåˆ¶ï¼ˆå¯é€‰ï¼‰

```rust
// middleware/auth.rs
use axum::{
    http::{Request, StatusCode},
    middleware::Next,
    response::Response,
};

pub async fn auth_middleware<B>(
    request: Request<B>,
    next: Next<B>,
) -> Result<Response, StatusCode> {
    let api_key = request
        .headers()
        .get("X-API-Key")
        .and_then(|v| v.to_str().ok());

    match api_key {
        Some(key) if validate_api_key(key) => Ok(next.run(request).await),
        _ => Err(StatusCode::UNAUTHORIZED),
    }
}

fn validate_api_key(key: &str) -> bool {
    let expected = std::env::var("API_KEY").unwrap_or_default();
    !expected.is_empty() && key == expected
}
```

---

## 14. æ€§èƒ½ä¼˜åŒ–

### 14.1 è¿æ¥æ± é…ç½®

```rust
MySqlPoolOptions::new()
    .max_connections(10)           // æœ€å¤§è¿æ¥æ•°
    .min_connections(1)            // æœ€å°è¿æ¥æ•°
    .acquire_timeout(Duration::from_secs(30))  // è·å–è¿æ¥è¶…æ—¶
    .idle_timeout(Duration::from_secs(600))    // ç©ºé—²è¿æ¥è¶…æ—¶
    .max_lifetime(Duration::from_secs(1800))   // è¿æ¥æœ€å¤§ç”Ÿå‘½å‘¨æœŸ
```

### 14.2 å“åº”å‹ç¼©

å·²å¯ç”¨ gzip/deflate/brotli å‹ç¼©ï¼Œå‡å°‘ç½‘ç»œä¼ è¾“ã€‚

### 14.3 æŸ¥è¯¢ç»“æœé™åˆ¶

- é»˜è®¤é™åˆ¶è¿”å› 1000 è¡Œ
- å¯é€šè¿‡ `limit` å‚æ•°è°ƒæ•´
- é˜²æ­¢å¤§ç»“æœé›†å¯¼è‡´å†…å­˜æº¢å‡º

### 14.4 Release ç¼–è¯‘ä¼˜åŒ–

```toml
[profile.release]
lto = "fat"           # é“¾æ¥æ—¶ä¼˜åŒ–
codegen-units = 1     # å•ä»£ç ç”Ÿæˆå•å…ƒ
opt-level = 3         # æœ€é«˜ä¼˜åŒ–çº§åˆ«
strip = "symbols"     # å‰¥ç¦»ç¬¦å·è¡¨
```

---

## 15. ç›‘æ§ä¸æŒ‡æ ‡

### 15.1 å¥åº·æ£€æŸ¥ç«¯ç‚¹

| ç«¯ç‚¹ | ç”¨é€” |
|------|------|
| `/api/health` | ç»¼åˆå¥åº·çŠ¶æ€ |
| `/api/health/ready` | å°±ç»ªæ¢é’ˆï¼ˆK8sï¼‰ |
| `/api/health/live` | å­˜æ´»æ¢é’ˆï¼ˆK8sï¼‰ |

### 15.2 Prometheus æŒ‡æ ‡ï¼ˆè§„åˆ’ä¸­ï¼‰

```rust
// ä½¿ç”¨ metrics crate
use metrics::{counter, histogram};

// è¯·æ±‚è®¡æ•°
counter!("http_requests_total", "method" => method, "path" => path, "status" => status);

// è¯·æ±‚è€—æ—¶
histogram!("http_request_duration_seconds", duration);

// è¿æ¥æ± çŠ¶æ€
gauge!("db_pool_connections_active", active_count, "db_type" => db_type);
gauge!("db_pool_connections_idle", idle_count, "db_type" => db_type);

// SQL æ‰§è¡Œ
counter!("sql_queries_total", "connection_id" => id, "success" => success);
histogram!("sql_query_duration_seconds", duration);
```

---

## 16. éƒ¨ç½²æ–¹æ¡ˆ

### 16.1 Docker éƒ¨ç½²

```dockerfile
# Dockerfile
FROM rust:1.75-slim as builder
WORKDIR /app
COPY . .
RUN cargo build --release

FROM debian:bookworm-slim
RUN apt-get update && apt-get install -y ca-certificates && rm -rf /var/lib/apt/lists/*
COPY --from=builder /app/target/release/databasemanager /usr/local/bin/
EXPOSE 8080
ENV RUST_LOG=info
CMD ["databasemanager"]
```

```yaml
# docker-compose.yml
version: '3.8'
services:
  databasemanager:
    build: .
    ports:
      - "8080:8080"
    environment:
      - RUST_LOG=info
      - SERVER_PORT=8080
      - DATA_DIR=/data
    volumes:
      - ./data:/data
    restart: unless-stopped
```

### 16.2 Kubernetes éƒ¨ç½²

```yaml
# k8s/deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: databasemanager
spec:
  replicas: 2
  selector:
    matchLabels:
      app: databasemanager
  template:
    metadata:
      labels:
        app: databasemanager
    spec:
      containers:
        - name: databasemanager
          image: your-registry/databasemanager:latest
          ports:
            - containerPort: 8080
          env:
            - name: RUST_LOG
              value: "info"
          livenessProbe:
            httpGet:
              path: /api/health/live
              port: 8080
            initialDelaySeconds: 5
            periodSeconds: 10
          readinessProbe:
            httpGet:
              path: /api/health/ready
              port: 8080
            initialDelaySeconds: 5
            periodSeconds: 10
          resources:
            requests:
              memory: "64Mi"
              cpu: "100m"
            limits:
              memory: "256Mi"
              cpu: "500m"
---
apiVersion: v1
kind: Service
metadata:
  name: databasemanager
spec:
  selector:
    app: databasemanager
  ports:
    - port: 80
      targetPort: 8080
  type: ClusterIP
```

---

## 17. æµ‹è¯•ç­–ç•¥

### 17.1 å•å…ƒæµ‹è¯•

```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_sql_validator() {
        assert!(SqlValidator::validate("SELECT * FROM users").is_ok());
        assert!(SqlValidator::validate("DROP TABLE users").is_err());
    }

    #[test]
    fn test_connection_config_serialization() {
        let config = ConnectionConfig {
            id: "test".into(),
            name: "Test".into(),
            db_type: DbType::MySQL,
            host: Some("localhost".into()),
            port: Some(3306),
            username: Some("root".into()),
            password: Some("secret".into()), // ä¸åº”å‡ºç°åœ¨ JSON ä¸­
            database: None,
            file_path: None,
            created_at: chrono::Utc::now(),
        };

        let json = serde_json::to_string(&config).unwrap();
        assert!(!json.contains("secret")); // å¯†ç ä¸åºåˆ—åŒ–
    }
}
```

### 17.2 é›†æˆæµ‹è¯•

```rust
// tests/api_tests.rs
use axum::http::StatusCode;
use axum_test::TestServer;

#[tokio::test]
async fn test_health_check() {
    let app = create_test_app().await;
    let server = TestServer::new(app).unwrap();

    let response = server.get("/api/health").await;
    assert_eq!(response.status_code(), StatusCode::OK);

    let body: serde_json::Value = response.json();
    assert_eq!(body["status"], "healthy");
}

#[tokio::test]
async fn test_create_connection() {
    let app = create_test_app().await;
    let server = TestServer::new(app).unwrap();

    let response = server
        .post("/api/connections")
        .json(&json!({
            "name": "Test DB",
            "type": "sqlite",
            "file_path": ":memory:"
        }))
        .await;

    assert_eq!(response.status_code(), StatusCode::CREATED);
}
```

### 17.3 æµ‹è¯•è¦†ç›–ç‡ç›®æ ‡

| æ¨¡å— | ç›®æ ‡è¦†ç›–ç‡ |
|------|-----------|
| models | > 90% |
| services | > 80% |
| routes | > 70% |
| db | > 60% |

---

## 19. ä¾èµ–é…ç½®

### 19.1 Cargo.toml

```toml
[package]
name = "databasemanager"
version = "0.1.0"
edition = "2021"
authors = ["Your Name <your@email.com>"]
description = "é«˜æ€§èƒ½æ•°æ®åº“ç®¡ç†åç«¯ï¼ˆæ”¯æŒ AI æ™ºèƒ½åŠŸèƒ½ï¼‰"
repository = "https://github.com/Superyby/DatabaseManagerment"

[dependencies]
# Web æ¡†æ¶
axum = "0.8"
tokio = { version = "1", features = ["full"] }
tower-http = { version = "0.6", features = ["cors", "trace", "compression-full"] }

# æ•°æ®åº“
sqlx = { version = "0.8", features = ["runtime-tokio-rustls", "mysql", "postgres", "sqlite"] }

# åºåˆ—åŒ–
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"

# æ—¥å¿—
tracing = "0.1"
tracing-subscriber = { version = "0.3", features = ["env-filter", "json"] }

# é”™è¯¯å¤„ç†
thiserror = "2.0"
anyhow = "1.0"

# å·¥å…·
chrono = { version = "0.4", features = ["serde"] }
uuid = { version = "1.0", features = ["v4", "serde"] }

# AI åŠŸèƒ½
reqwest = { version = "0.12", features = ["json"] }
async-trait = "0.1"

[dev-dependencies]
axum-test = "14"

[profile.release]
lto = "fat"
codegen-units = 1
opt-level = 3
strip = "symbols"
```

---

## 20. å¼€å‘è·¯çº¿å›¾

### Phase 1: MVP âœ… è¿›è¡Œä¸­

- [x] é¡¹ç›®è„šæ‰‹æ¶
- [x] å¥åº·æ£€æŸ¥ API
- [x] æ¶æ„è®¾è®¡æ–‡æ¡£
- [ ] æ¨¡å—æ‹†åˆ†é‡æ„
- [ ] ç»Ÿä¸€é”™è¯¯å¤„ç†
- [ ] è¿æ¥ç®¡ç† CRUD
- [ ] é…ç½®æŒä¹…åŒ–

### Phase 2: æ ¸å¿ƒåŠŸèƒ½

- [ ] åŠ¨æ€è¿æ¥æ± ç®¡ç†
- [ ] SQL æŸ¥è¯¢æ‰§è¡Œ
- [ ] æŸ¥è¯¢ç»“æœè§£æ
- [ ] ç»“æœè¡Œæ•°é™åˆ¶

### Phase 3: AI æ™ºèƒ½åŠŸèƒ½ â­ æ–°å¢

- [ ] LLM å®¢æˆ·ç«¯å°è£… (Claude/OpenAI)
- [ ] Schema ç®¡ç†å™¨
- [ ] è‡ªç„¶è¯­è¨€è½¬ SQL (Text-to-SQL)
- [ ] SQL æ™ºèƒ½ä¼˜åŒ–å»ºè®®
- [ ] æŸ¥è¯¢ç»“æœåˆ†æ
- [ ] æ™ºèƒ½é—®ç­”

### Phase 4: å¢å¼ºåŠŸèƒ½

- [ ] API Key è®¤è¯
- [ ] SQL å®‰å…¨æ£€æŸ¥
- [ ] æ“ä½œå®¡è®¡æ—¥å¿—
- [ ] è¿æ¥æ± ç›‘æ§

### Phase 5: ç”Ÿäº§å°±ç»ª

- [ ] å•å…ƒæµ‹è¯• (>80%)
- [ ] é›†æˆæµ‹è¯•
- [ ] Docker é•œåƒ
- [ ] CI/CD æµæ°´çº¿
- [ ] Prometheus æŒ‡æ ‡
- [ ] K8s éƒ¨ç½²é…ç½®

---

## é™„å½•

### A. ç¯å¢ƒå˜é‡

| å˜é‡å | é»˜è®¤å€¼ | è¯´æ˜ |
|--------|--------|------|
| `SERVER_HOST` | `0.0.0.0` | ç›‘å¬åœ°å€ |
| `SERVER_PORT` | `8080` | ç›‘å¬ç«¯å£ |
| `RUST_LOG` | `info` | æ—¥å¿—çº§åˆ« |
| `MAX_CONNECTIONS` | `10` | è¿æ¥æ± æœ€å¤§è¿æ¥æ•° |
| `CONNECT_TIMEOUT` | `30` | è¿æ¥è¶…æ—¶ï¼ˆç§’ï¼‰ |
| `DATA_DIR` | `./data` | æ•°æ®å­˜å‚¨ç›®å½• |
| `API_KEY` | - | API è®¤è¯å¯†é’¥ï¼ˆå¯é€‰ï¼‰ |
| **AI é…ç½®** | | |
| `AI_ENABLED` | `false` | æ˜¯å¦å¯ç”¨ AI åŠŸèƒ½ |
| `AI_PROVIDER` | `claude` | LLM æä¾›å•† (claude/openai/ollama) |
| `AI_API_KEY` | - | LLM API å¯†é’¥ |
| `AI_MODEL` | `claude-sonnet-4-20250514` | æ¨¡å‹åç§° |
| `AI_BASE_URL` | - | è‡ªå®šä¹‰ API ç«¯ç‚¹ |
| `AI_MAX_TOKENS` | `4096` | æœ€å¤§è¾“å‡º tokens |
| `AI_TEMPERATURE` | `0.1` | æ¸©åº¦å‚æ•° (0-1) |

### B. ç›®å½•ç»“æ„å¯¹æ¯”

#### ä¼˜åŒ–å‰
```
src/
â”œâ”€â”€ main.rs          # æ‰€æœ‰ä»£ç æ··åœ¨ä¸€èµ· (86è¡Œ)
â”œâ”€â”€ routes/
â”‚   â”œâ”€â”€ mod.rs       # 1è¡Œ
â”‚   â”œâ”€â”€ health.rs    # ç©º
â”‚   â””â”€â”€ database.rs  # ç©º
â””â”€â”€ models/
    â”œâ”€â”€ mod.rs       # 1è¡Œ
    â””â”€â”€ database.rs  # ç©º
```

#### ä¼˜åŒ–å
```
src/
â”œâ”€â”€ main.rs          # ä»…å¯åŠ¨é€»è¾‘ (~50è¡Œ)
â”œâ”€â”€ lib.rs           # åº“å…¥å£
â”œâ”€â”€ config.rs        # é…ç½®ç®¡ç†
â”œâ”€â”€ state.rs         # åº”ç”¨çŠ¶æ€
â”œâ”€â”€ routes/          # è·¯ç”±å±‚ (3ä¸ªæ–‡ä»¶)
â”œâ”€â”€ models/          # æ¨¡å‹å±‚ (4ä¸ªæ–‡ä»¶)
â”œâ”€â”€ services/        # æœåŠ¡å±‚ (3ä¸ªæ–‡ä»¶)
â”œâ”€â”€ db/              # æ•°æ®å±‚ (3ä¸ªæ–‡ä»¶)
â”œâ”€â”€ errors/          # é”™è¯¯å¤„ç† (2ä¸ªæ–‡ä»¶)
â”œâ”€â”€ middleware/      # ä¸­é—´ä»¶ (3ä¸ªæ–‡ä»¶)
â””â”€â”€ utils/           # å·¥å…· (3ä¸ªæ–‡ä»¶)
```

### C. å‚è€ƒèµ„æ–™

- [Axum å®˜æ–¹æ–‡æ¡£](https://docs.rs/axum)
- [SQLx å®˜æ–¹æ–‡æ¡£](https://docs.rs/sqlx)
- [Tokio å®˜æ–¹æ–‡æ¡£](https://tokio.rs)
- [Tower ä¸­é—´ä»¶](https://docs.rs/tower-http)
